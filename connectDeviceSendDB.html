<!DOCTYPE html>
<html>
<head>
  <title>PWA IndexedDB Sharing via WebRTC</title>
</head>
<body>
<h1>PWA DB Sharing Example</h1>

<textarea id="log" rows="15" cols="80" readonly></textarea><br/>
<button id="startCallBtn">Start Call (Offerer)</button>
<button id="answerCallBtn">Answer Call (Answerer)</button><br/><br/>

<textarea id="localSDP" placeholder="Local SDP" rows="6" cols="80"></textarea><br/>
<textarea id="remoteSDP" placeholder="Paste Remote SDP here" rows="6" cols="80"></textarea><br/>
<button id="setRemoteSDPbtn">Set Remote SDP</button><br/><br/>

<button id="sendDataBtn" disabled>Send DB Data</button>

<script>
// IndexedDB utils
const dbName = "myPwaDB";
const storeName = "myStore";

// Open DB and create store if needed
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(dbName, 1);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(storeName)) {
        db.createObjectStore(storeName, { keyPath: "id" });
      }
    };
  });
}

// Add sample data
async function addSampleData() {
  const db = await openDB();
  const tx = db.transaction(storeName, "readwrite");
  const store = tx.objectStore(storeName);
  await store.put({ id: "1", data: "Hello from PWA 1!" });
  await tx.complete;
}

// Read all data from IndexedDB
async function readAllData() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const store = tx.objectStore(storeName);
    const items = [];
    const request = store.openCursor();
    request.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        items.push(cursor.value);
        cursor.continue();
      } else {
        resolve(items);
      }
    };
    request.onerror = () => reject(request.error);
  });
}

// Write array of objects to IndexedDB
async function writeAllData(items) {
  const db = await openDB();
  const tx = db.transaction(storeName, "readwrite");
  const store = tx.objectStore(storeName);
  for (const item of items) {
    await store.put(item);
  }
  await tx.complete;
}

// Logging helper
function log(msg) {
  logArea.value += msg + "\n";
  logArea.scrollTop = logArea.scrollHeight;
}

// WebRTC vars
let pc;
let dataChannel;

const logArea = document.getElementById("log");
const startCallBtn = document.getElementById("startCallBtn");
const answerCallBtn = document.getElementById("answerCallBtn");
const localSDPText = document.getElementById("localSDP");
const remoteSDPText = document.getElementById("remoteSDP");
const setRemoteSDPbtn = document.getElementById("setRemoteSDPbtn");
const sendDataBtn = document.getElementById("sendDataBtn");

// Chunk large string into parts of given size
function chunkString(str, length) {
  let chunks = [];
  let i = 0;
  while (i < str.length) {
    chunks.push(str.slice(i, i + length));
    i += length;
  }
  return chunks;
}

// Create peer connection & set event handlers
function createPeerConnection(isOfferer) {
  pc = new RTCPeerConnection();

  if (isOfferer) {
    dataChannel = pc.createDataChannel("pwaData");
    setupDataChannel();
  } else {
    pc.ondatachannel = (event) => {
      dataChannel = event.channel;
      setupDataChannel();
    };
  }

  pc.onicecandidate = (event) => {
    if (!event.candidate) {
      localSDPText.value = JSON.stringify(pc.localDescription);
      log("Local SDP set");
    }
  };
}

function setupDataChannel() {
  dataChannel.onopen = () => {
    log("Data channel is open");
    sendDataBtn.disabled = false;
  };
  dataChannel.onclose = () => {
    log("Data channel is closed");
    sendDataBtn.disabled = true;
  };
  let receivedData = "";
  dataChannel.onmessage = async (event) => {
    if (event.data === "__END__") {
      log("DB data fully received, parsing...");
      const dbObjects = JSON.parse(receivedData);
      await writeAllData(dbObjects);
      log("DB data written to IndexedDB");
      receivedData = "";
    } else {
      receivedData += event.data;
      log(`Received chunk size: ${event.data.length}`);
    }
  };
}

startCallBtn.onclick = async () => {
  createPeerConnection(true);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
};

answerCallBtn.onclick = async () => {
  createPeerConnection(false);
  const offer = JSON.parse(localSDPText.value);
  await pc.setRemoteDescription(offer);
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  localSDPText.value = JSON.stringify(pc.localDescription);
};

setRemoteSDPbtn.onclick = async () => {
  const remoteDesc = JSON.parse(remoteSDPText.value);
  await pc.setRemoteDescription(remoteDesc);
  log("Remote SDP set");
};

sendDataBtn.onclick = async () => {
  if (!dataChannel || dataChannel.readyState !== "open") {
    alert("Data channel not open");
    return;
  }
  const allData = await readAllData();
  const serialized = JSON.stringify(allData);
  const chunks = chunkString(serialized, 16000); // 16Kb chunks

  log(`Sending DB data in ${chunks.length} chunks`);
  for (const chunk of chunks) {
    dataChannel.send(chunk);
  }
  dataChannel.send("__END__");
  log("DB data send complete");
};

// Add sample data to DB on load
addSampleData().then(() => log("Sample data added to IndexedDB"));
</script>
</body>
</html>
