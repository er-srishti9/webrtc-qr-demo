<!DOCTYPE html>
<html>
<head>
  <title>PWA IndexedDB Sync with WebRTC and Dummy Data</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: auto; }
    textarea { width: 100%; font-family: monospace; }
    button { margin-top: 10px; padding: 10px 20px; font-size: 1em; }
    #log { background: #f0f0f0; margin-top: 20px; height: 200px; overflow-y: auto; padding: 10px; }
  </style>
</head>
<body>

<h1>WebRTC IndexedDB Sync with Manual SDP and Dummy Data</h1>

<button id="btnStartOffer">Start Call (Create Offer)</button><br/>
<textarea id="offerSdp" rows="6" placeholder="Offer SDP"></textarea><br/>

<button id="btnStartAnswer">Answer Call (Create Answer)</button><br/>
<textarea id="answerSdp" rows="6" placeholder="Answer SDP"></textarea><br/>

<textarea id="remoteSdp" rows="6" placeholder="Paste remote SDP here"></textarea><br/>
<button id="btnSetRemote">Set Remote Description</button><br/>

<button id="btnAddDummyData">Add Dummy Data to IndexedDB</button><br/>
<button id="btnSendData" disabled>Send IndexedDB Data</button>

<div id="log"></div>

<script>
  const logEl = document.getElementById('log');
  function log(msg) {
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(msg);
  }

  // IndexedDB helpers
  const dbName = "pwaSyncDB";
  const storeName = "items";

  function openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, 1);
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: "id" });
        }
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async function writeDataToIndexedDB(items) {
    const db = await openDB();
    const tx = db.transaction(storeName, "readwrite");
    const store = tx.objectStore(storeName);
    for (const item of items) {
      await store.put(item);
    }
    return tx.complete;
  }

  async function readDataFromIndexedDB() {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(storeName, "readonly");
      const store = tx.objectStore(storeName);
      const results = [];
      const request = store.openCursor();
      request.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(results);
        }
      };
      request.onerror = (e) => reject(e);
    });
  }

  // Add dummy data button handler
  document.getElementById('btnAddDummyData').onclick = async () => {
    const dummyData = [
      { id: 1, text: "Dummy note 1", timestamp: Date.now() },
      { id: 2, text: "Dummy note 2", timestamp: Date.now() },
      { id: 3, text: "Dummy note 3", timestamp: Date.now() }
    ];
    await writeDataToIndexedDB(dummyData);
    log("Dummy data added to IndexedDB.");
  };

  // WebRTC setup
  let pc;
  let dataChannel;

  const btnStartOffer = document.getElementById("btnStartOffer");
  const offerSdpTextarea = document.getElementById("offerSdp");
  const btnStartAnswer = document.getElementById("btnStartAnswer");
  const answerSdpTextarea = document.getElementById("answerSdp");
  const remoteSdpTextarea = document.getElementById("remoteSdp");
  const btnSetRemote = document.getElementById("btnSetRemote");
  const btnSendData = document.getElementById("btnSendData");

  function createPeerConnection(isOfferer) {
    pc = new RTCPeerConnection();

    if (isOfferer) {
      dataChannel = pc.createDataChannel("pwaSyncChannel");
      setupDataChannel();
    } else {
      pc.ondatachannel = (event) => {
        dataChannel = event.channel;
        setupDataChannel();
      };
    }

    pc.onicecandidate = (event) => {
      if (!event.candidate) {
        const desc = pc.localDescription;
        if (isOfferer) {
          offerSdpTextarea.value = JSON.stringify(desc);
          log("Offer SDP created");
        } else {
          answerSdpTextarea.value = JSON.stringify(desc);
          log("Answer SDP created");
        }
      }
    };
  }

  function setupDataChannel() {
    dataChannel.onopen = () => {
      log("Data channel open");
      btnSendData.disabled = false;
    };
    dataChannel.onclose = () => {
      log("Data channel closed");
      btnSendData.disabled = true;
    };
    let receivedData = "";
    dataChannel.onmessage = async (event) => {
      if (event.data === "__END__") {
        log("All data received, saving to IndexedDB...");
        const items = JSON.parse(receivedData);
        await writeDataToIndexedDB(items);
        log("Data saved to IndexedDB: " + JSON.stringify(items));
        receivedData = "";
      } else {
        receivedData += event.data;
      }
    };
  }

  function chunkString(str, size = 16000) {
    const chunks = [];
    for (let i = 0; i < str.length; i += size) {
      chunks.push(str.slice(i, i + size));
    }
    return chunks;
  }

  btnStartOffer.onclick = async () => {
    createPeerConnection(true);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
  };

  btnStartAnswer.onclick = async () => {
    createPeerConnection(false);
    const offerDesc = JSON.parse(offerSdpTextarea.value);
    await pc.setRemoteDescription(offerDesc);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
  };

  btnSetRemote.onclick = async () => {
    const remoteDesc = JSON.parse(remoteSdpTextarea.value);
    await pc.setRemoteDescription(remoteDesc);
    log("Remote SDP set");
  };

  btnSendData.onclick = async () => {
    if (!dataChannel || dataChannel.readyState !== "open") {
      alert("Data channel is not open!");
      return;
    }
    const allData = await readDataFromIndexedDB();
    const serialized = JSON.stringify(allData);
    const chunks = chunkString(serialized);

    log(`Sending data in ${chunks.length} chunks...`);
    for (const chunk of chunks) {
      dataChannel.send(chunk);
    }
    dataChannel.send("__END__");
    log("Data sending complete.");
  };
</script>

</body>
</html>
